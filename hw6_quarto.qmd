---
title: "Homework 6"
author: Ethan Marburger
format: html
editor: visual
---

# Task 1: Conceptual Questions

**1) What is the purpose of the lapply() function? What is the equivalent purrr function?**

lapply() is used to apply functions to lists. The equivalent of lapply() in the purrr package are the map() functions.
  
**2) Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = "kendall")on each element of the list. Write code to do this below!**

numeric_matrix <- lapply(X = my_list, FUN = cor, method = "kendall")
  
**3) What are two advantages of using purrr functions instead of the BaseR apply family?**

purrr gives us a cleaner/more consistent way to apply function to objects as well as helper functions to do so.

**4) What is a side-effect function?**

Side-effect functions return values without returning the modified output.

**5) Why can you name a variable sd in a function and not cause any issues with the sd function?**

A variable named "sd" in a function does not influence the *sd function* because it is generated by the function in a separate environment that disappears when the function finishes. 


# Task 2: Writing R Functions

1) Creating a RMSE function that takes in a vector of responses and a vector of predictions and outputs the RMSE

```{r}
getRMSE <- function(responses, predictions, ...) {
  RMSE <- sqrt(mean((responses - predictions)^2, ...)) #additional argument for the mean function
  return(RMSE)
}

# Testing RMSE function

responses1 = c(35, 36, 43, 47, 48, 49, 46, 43, 42, 37, 36, 40)
predictions1 = c(37, 37, 43, 46, 46, 50, 45, 44, 43, 41, 32, 42)

getRMSE(responses1, predictions1)

```

2) Running the provided code to create some response and prediction values.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Testing RMSE function using provided data

```{r}
test_rmse <- getRMSE(resp, pred)
print(test_rmse)
```

Replacing two values with NA then rerunning getRMSE()

```{r}
# replacing two response values with NA
resp[c(23, 68)] <- NA_real_

# getRMSE function without specifying missing values
rmse_without <- getRMSE(resp, pred)
print(rmse_without)

# getRMSE function with specifying missing values
rmse_with <- getRMSE(resp, pred, na.rm = TRUE)

print(rmse_with)
```

3) Function to get the Mean Absolute Deviation 

```{r}
# Mean Absolute Deviation Function
getMAE <- function(responses, predictions, ...) {
  MAE <- mean(abs(responses - predictions), ...) #additional argument for the mean function
  return(MAE)
}
```

4. Running the provided code to create some response and prediction values.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Testing MAE Function

```{r}
# MAE Function
test_mae <- getMAE(resp, pred)
print(test_mae)
```
Replacing two values with NA then rerunning getMAE()
```{r}
# replacing two response values with NA
resp[c(21, 79)] <- NA_real_

# getMAE function without specifying missing values
mae_without <- getRMSE(resp, pred)
print(mae_without)

# getRMSE function with specifying missing values
mae_with <- getMAE(resp, pred, na.rm = TRUE)

print(mae_with)
```

5) Wrapper function that can be used to get either or both metrics returned with a single function call

```{r}
# Function that takes in two vectors, checks requirements, and applies helper functions
wrapper_function <- function(resp, pred, metrics = c("RMSE", "MAE")) {
  
  if (!is.vector(resp) || !is.vector(pred))
    stop("Both inputs need to be vectors")
  if (!is.atomic(resp) || !is.atomic(pred))
    stop("Both inputs need to be atomic vectors")
  if (!is.numeric(resp) || !is.numeric(pred))
    stop("Both inputs need to be numeric")
  
  results <- list()
  
  if ("RMSE" %in% metrics) {
    results$RMSE <- getRMSE(resp, pred, na.rm = TRUE)}
  if ("MAE" %in% metrics) {
    results$MAE <- getMAE(resp, pred, na.rm = TRUE)}
  
  return(results)
}
```

6) Running the following code to create some response values and predictions.

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Testing wrapper function using new data specifying RMSE metric

```{r}
wrapper <- wrapper_function(resp, pred, metrics = c("RMSE"))
print(wrapper)
```

Testing wrapper function using new data specifying MAE metric

```{r}
wrapper <- wrapper_function(resp, pred, metrics = c("MAE"))
print(wrapper)
```


Testing wrapper function using new data specifying both metrics

```{r}
wrapper <- wrapper_function(resp, pred, metrics = c("RMSE", "MAE"))
print(wrapper)
```
Repeat with replacing two of the response values with missing values (NA_real_)

```{r}
# replacing two response values with NA
resp[c(28, 62)] <- NA_real_

# Retesting function with missing response values
wrapper <- wrapper_function(resp, pred, metrics = c("RMSE", "MAE"))
print(wrapper)
```

Finally, test your function by passing it incorrect data (i.e. a data frame or something else instead of vectors)

```{r}
# attemping to pass the iris data.frame through function
wrapper <- wrapper_function(iris, pred, metrics = c("RMSE", "MAE"))
print(wrapper)
```

# Task 3: Querying an API and a Tidy-Style Function


```{r}
# Required libraries
library(tidyverse)
library(tidyjson)
library(jsonlite)
library(purrr)
library(httr)
```

1) Set-up a connection with the given news API to return information about a topic of interest
```{r}
api_key <- "08daecb0bc2c4de6a6de13133cbe1217"

topic <- "US Business Headlines"

url <- "https://newsapi.org/v2/top-headlines?country=us&category=business&apiKey=08daecb0bc2c4de6a6de13133cbe1217"

parameters <- list(from = 2024-10-00, 
                   sortBy = "relevancy")

US_business_news <- GET(url, query = parameters)

str(US_business_news, max.level = 1)
```

2) Parse what is returned and find your way to the data frame that has the actual article information in it (check content). Use the pluck() function from purrr to grab the articles element. Note the first column should be a list column

```{r}
#  Parse what is returned and find your way to the data frame
parsed <- fromJSON(rawToChar(US_business_news$content))

article_df <- pluck(parsed, "articles")

business_articles <- as_tibble(
  source = list(articles_df$source),
  author = articles_df$author,
  title = articles_df$title,
  description = articles_df$description,
  url = articles_df$url,
  urlToImage = articles_df$urlToImage,
  publishedAt = articles_df$publishedAt,
  content = articles_df$content
)

business_articles
```
3) Write a quick function that allows the user to easily query this API. The inputs to the function should be the title/subject to search for (string), a time period to search from (string - youâ€™ll search from that time until the present), and an API key.

```{r}
api_query <- function(title, from_date, api_key) {
  
  url <- "https://newsapi.org/v2/top-headlines?country=us&category=business&apiKey=08daecb0bc2c4de6a6de13133cbe1217"
  
  parameters <- list(from = from_date, 
                   sortBy = "relevancy")
  
  git_request <- GET(url, query = parameters)
  
  parsed <- fromJSON(rawToChar(US_business_news$content))
  articles <- pluck(parsed, "articles")
  business_articles <- as_tibble(articles)

  return(business_articles)
}
```

Using function twice to grab some data!

```{r}
# Defining function argument
api_key <- "08daecb0bc2c4de6a6de13133cbe1217"
title = "The FTC just made canceling subscriptions easier with new 'click-to-cancel' rule - Quartz"
# Testing function
api_fun_test <- api_query(title, "2024-10-15", api_key)

print(api_fun_test)
```

