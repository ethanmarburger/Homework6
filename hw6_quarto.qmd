---
title: "Homework 6"
author: Ethan Marburger
format: html
editor: visual
---

# Task 1: Conceptual Questions

**1) What is the purpose of the lapply() function? What is the equivalent purrr function?**

lapply() is used to apply functions to lists. The equivalent of lapply() in the purrr package are the map() functions.

**2) Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = "kendall")on each element of the list. Write code to do this below!**

numeric_matrix <- lapply(X = my_list, FUN = cor, method = "kendall")

**3) What are two advantages of using purrr functions instead of the BaseR apply family?**

purrr gives us a cleaner/more consistent way to apply function to objects as well as helper functions to do so.

**4) What is a side-effect function?**

Side-effect functions return values without returning the modified output.

**5) Why can you name a variable sd in a function and not cause any issues with the sd function?**

A variable named "sd" in a function does not influence the *sd function* because it is generated by the function in a separate environment that disappears when the function finishes.

# Task 2: Writing R Functions

**1)  Creating a RMSE function that takes in a vector of responses and a vector of predictions and outputs the RMSE**

```{r}
getRMSE <- function(responses, predictions, ...) {
  RMSE <- sqrt(mean((responses - predictions)^2, ...)) #additional argument for the mean function
  return(RMSE)
}

# Testing RMSE function

responses1 = c(35, 36, 43, 47, 48, 49, 46, 43, 42, 37, 36, 40)
predictions1 = c(37, 37, 43, 46, 46, 50, 45, 44, 43, 41, 32, 42)

getRMSE(responses1, predictions1)

```

**2)  Running the provided code to create some response and prediction values.**

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))
```

Testing RMSE function using provided data

```{r}
test_rmse <- getRMSE(resp, pred)
print(test_rmse)
```

Replacing two values with NA then rerunning getRMSE()

```{r}
# replacing two response values with NA
resp[c(23, 68)] <- NA_real_

# getRMSE function without specifying missing values
rmse_without <- getRMSE(resp, pred)
print(rmse_without)

# getRMSE function with specifying missing values
rmse_with <- getRMSE(resp, pred, na.rm = TRUE)

print(rmse_with)
```

**3)  Function to get the Mean Absolute Deviation**

```{r}
# Mean Absolute Deviation Function
getMAE <- function(responses, predictions, ...) {
  MAE <- mean(abs(responses - predictions), ...) #additional argument for the mean function
  return(MAE)
}

```

**4.  Running the provided code to create some response and prediction values.**

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

```

Testing MAE Function

```{r}
# MAE Function
test_mae <- getMAE(resp, pred)
print(test_mae)

```

Replacing two values with NA then rerunning getMAE()

```{r}
# replacing two response values with NA
resp[c(21, 79)] <- NA_real_

# getMAE function without specifying missing values
mae_without <- getRMSE(resp, pred)
print(mae_without)

# getRMSE function with specifying missing values
mae_with <- getMAE(resp, pred, na.rm = TRUE)

print(mae_with)

```

**5)  Wrapper function that can be used to get either or both metrics returned with a single function call**

```{r}
# Function that takes in two vectors, checks requirements, and applies helper functions
wrapper_function <- function(resp, pred, metrics = c("RMSE", "MAE")) {
  
  if (!is.vector(resp) || !is.vector(pred))
    stop("Both inputs need to be vectors")
  if (!is.atomic(resp) || !is.atomic(pred))
    stop("Both inputs need to be atomic vectors")
  if (!is.numeric(resp) || !is.numeric(pred))
    stop("Both inputs need to be numeric")
  
  results <- list()
  
  if ("RMSE" %in% metrics) {
    results$RMSE <- getRMSE(resp, pred, na.rm = TRUE)}
  if ("MAE" %in% metrics) {
    results$MAE <- getMAE(resp, pred, na.rm = TRUE)}
  
  return(results)
}

```

**6)  Running the following code to create some response values and predictions.**

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

```

Testing wrapper function using new data specifying RMSE metric

```{r}
wrapper <- wrapper_function(resp, pred, metrics = c("RMSE"))
print(wrapper)

```

Testing wrapper function using new data specifying MAE metric

```{r}
wrapper <- wrapper_function(resp, pred, metrics = c("MAE"))
print(wrapper)

```

Testing wrapper function using new data specifying both metrics

```{r}
wrapper <- wrapper_function(resp, pred, metrics = c("RMSE", "MAE"))
print(wrapper)

```

Repeat with replacing two of the response values with missing values (NA_real\_)

```{r}
# replacing two response values with NA
resp[c(28, 62)] <- NA_real_

# Retesting function with missing response values
wrapper <- wrapper_function(resp, pred, metrics = c("RMSE", "MAE"))
print(wrapper)

```

Finally, test your function by passing it incorrect data (i.e. a data frame or something else instead of vectors)

```{r}
# attemping to pass the iris data.frame through function

# wrapper <- wrapper_function(iris, pred, metrics = c("RMSE", "MAE"))

# did not execute, returned "Both inputs need to be vectors"
# File wouldn't render with error
```

# Task 3: Querying an API and a Tidy-Style Function

```{r}
# Required libraries
library(tidyverse)
library(tidyjson)
library(jsonlite)
library(purrr)
library(httr)

```

**1)  Set-up a connection with the given news API to return information about a topic of interest**

```{r}
api_key <- "08daecb0bc2c4de6a6de13133cbe1217"

topic <- "Articles that mentioned apple yesterday"

url <- "https://newsapi.org/v2/everything?q=apple&from=2024-10-15&to=2024-10-15&sortBy=popularity&apiKey=08daecb0bc2c4de6a6de13133cbe1217"

parameters <- list(from = 2024-10-00, 
                   sortBy = "relevancy")

apple_articles <- GET(url, query = parameters)

str(apple_articles, max.level = 1)

```

**2)  Parse what is returned and find your way to the data frame that has the actual article information in it (check content). Use the pluck() function from purrr to grab the articles element. Note the first column should be a list column**

```{r}
parsed <- fromJSON(rawToChar(apple_articles$content))

article_df <- pluck(parsed, "articles")

parsed_apple_articles <- as.tibble(article_df)
parsed_apple_articles

```

**3)  Write a quick function that allows the user to easily query this API. The inputs to the function should be the title/subject to search for (string), a time period to search from (string - you’ll search from that time until the present), and an API key.**

```{r}
library(httr)
library(jsonlite)
library(dplyr)

# Used author instead of title/subject
# Author seems like the better option as its shorter and multiple values that are the same

api_query <- function(author_name, from_date, api_key) {
  
  # api_key argument dynamically in the URL
  url <- paste0("https://newsapi.org/v2/everything?q=apple&from=2024-10-15&to=2024-10-15&sortBy=popularity&apiKey=08daecb0bc2c4de6a6de13133cbe1217", api_key)
  
  # Set up query parameters
  parameters <- list(from = from_date, sortBy = "relevancy")
  
  # Make the GET request
  request <- GET(url, query = parameters)
  
  # Parse the API response
 parsed <- fromJSON(rawToChar(apple_articles$content))

 article_df <- pluck(parsed, "articles")

 parsed_apple_articles <- as.tibble(article_df)
  
  # Filter the articles by title (exact match)
  desired_article <- filter(parsed_apple_articles, author == author_name)
  
  # Check if the desired article exists
  if(nrow(desired_article) == 0) {
    return(tibble(message = "No article found with that title"))
  }
  
  # Select relevant information and return it as a tibble
  article_info <- desired_article |>
    select(author, title, description, publishedAt, url)
  
  return(article_info)
}

```

Using function twice to grab some data!

```{r}
# Defining function argument
api_key <- "08daecb0bc2c4de6a6de13133cbe1217"

author_name <- c("Gizmodo Deals", "Jay Peters", "Kyle Barr")

# Testing function 1
articles1 <- api_query(author_name, "2024-10-00", api_key)
print(articles1)

```

```{r}
# Testing function 2
author_name <- c("Joe Tilleli", "Florence Ion", "Wes Davis")

articles2 <- api_query(author_name, "2024-10-00", api_key)
print(articles2)
```

**4) With one of your objects, summarize the name of the source for each article. That is, find a one-way contingency table for this information.**

```{r}
# one-way contingency table
table(articles1$author)
```

**5) For each of your returned data objects, turn the publishedAt column into a date column using the lubridate package (see the PARSE DATE-TIMES section of the cheat sheet!). Then sort the two data frames, each by their new parsed date published column. Finally, create a new variable called pub_diff that is the difference in time between the articles’ published dates (use lag() with mutate()). Save the modifications as new data frames.**

```{r}

library(lubridate)
articles1 <- articles1 |> 
  mutate(publishedAt = ymd_hms(publishedAt)) |> #converting to ymd format
  mutate(publishedAt = as.Date(publishedAt)) |> #keeping only the date
  arrange(publishedAt) |> # sorting column
  mutate(pub_diff = publishedAt - lag(publishedAt)) # difference in pub date

articles2 <- articles2 |> 
  mutate(publishedAt = ymd_hms(publishedAt)) |> #converting to ymd format
  mutate(publishedAt = as.Date(publishedAt)) |> #keeping only the date
  arrange(publishedAt) |># sorting column
  mutate(pub_diff = publishedAt - lag(publishedAt)) # difference in pub date
```

**6) Using both of your data frames, Subset the data frame to only return the date version of publishedAt and the pub_diff variables. Then use one call to the map() function to return the mean, standard deviation, and median of these columns. You should use a custom anonymous function using ‘shorthand’ notation (\(x) ...). Note that the pub_diff variable includes an NA so you’ll need to set na.rm = TRUE in the calls to mean(0, sd(), and median().**

```{r}
# Subsetting and calculating mean, median, and sd for both publishedAt and pub_diff
articles1_pub_summary <- articles1 |>
  select(publishedAt, pub_diff) |>
  map(~ list(mean = mean(.x, na.rm = TRUE), 
             sd = sd(.x, na.rm = TRUE), 
             median = median(.x, na.rm = TRUE)))

articles1_pub_summary
```

```{r}
# Subsetting and calculating mean, median, and sd for both publishedAt and pub_diff
articles2_pub_summary <- articles2 |>
  select(publishedAt, pub_diff) |>
  map(~ list(mean = mean(.x, na.rm = TRUE), 
             sd = sd(.x, na.rm = TRUE), 
             median = median(.x, na.rm = TRUE)))

articles2_pub_summary
```

